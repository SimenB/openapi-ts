import type {
  ICodegenBiMap,
  ICodegenFile,
  ICodegenImport,
  ICodegenMeta,
  ICodegenRenderer,
} from '@hey-api/codegen-core';
import { replaceWrappedIds } from '@hey-api/codegen-core';
import ts from 'typescript';

import { ensureValidIdentifier } from '../openApi/shared/utils/identifier';
import { tsc } from '../tsc';
import { tsNodeToString } from '../tsc/utils';

export class TypeScriptRenderer implements ICodegenRenderer {
  id = 'typescript';

  private ensureValidName(name: string): string {
    return ensureValidIdentifier(name);
  }

  private getUniqueName(
    base: string,
    names: ICodegenBiMap<number, string>,
  ): string {
    let index = 2;
    let name = base;
    while (names.hasValue(name)) {
      name = `${base}${index}`;
      index += 1;
    }
    return name;
  }

  private groupByKey(
    file: ICodegenFile,
    group: 'exports' | 'imports',
    meta?: ICodegenMeta,
  ): Map<string, Array<ICodegenImport>> {
    const grouped = new Map<string, Array<ICodegenImport>>();

    for (const value of file[group]) {
      const shouldAppendJs =
        meta?.moduleResolution === ts.ModuleResolutionKind.NodeNext;
      const key =
        typeof value.from === 'string'
          ? value.from
          : `${file.relativePathToFile(value.from)}${shouldAppendJs ? '.js' : ''}`;
      if (!grouped.has(key)) {
        grouped.set(key, []);
      }
      grouped.get(key)!.push(value);
    }

    return grouped;
  }

  private renderBody(file: ICodegenFile): string {
    const results: Array<string> = [];
    for (const symbol of file.symbols) {
      if (!symbol.value) continue;
      if (typeof symbol.value === 'string') {
        results.push(symbol.value);
      } else if (symbol.value instanceof Array) {
        symbol.value.forEach((node) => {
          results.push(`${tsNodeToString({ node, unescape: true })}\n`);
        });
      } else {
        results.push(
          `${tsNodeToString({ node: symbol.value as any, unescape: true })}\n`,
        );
      }
    }
    let body = results.join('\n');
    body = replaceWrappedIds(body, (symbolId) =>
      this.replacerFn({ file, headless: false, scope: 'file', symbolId }),
    );
    return body;
  }

  private renderExports(file: ICodegenFile, meta?: ICodegenMeta): string {
    const grouped = this.groupByKey(file, 'exports', meta);
    const statements: Array<string> = [];

    for (const [from, group] of grouped.entries()) {
      const isTypeOnly = group.every(
        (value) =>
          value.typeDefaultImport ||
          value.typeNamespaceImport ||
          value.names?.every((name) => value.typeNames?.includes(name)),
      );

      if (group.length === 1 && group[0]!.namespaceImport) {
        const exportClause =
          typeof group[0]!.namespaceImport === 'string'
            ? ts.factory.createNamespaceExport(
                tsc.identifier({ text: group[0]!.namespaceImport }),
              )
            : undefined;
        const node = ts.factory.createExportDeclaration(
          undefined,
          false,
          exportClause,
          tsc.stringLiteral({ isSingleQuote: true, text: from }),
        );
        statements.push(tsNodeToString({ node }));
        continue;
      }

      const namedSpecifiers: Array<ts.ExportSpecifier> = [];
      for (const value of group) {
        for (const name of value.names ?? []) {
          const alias = value.aliases?.[name];
          const specifier =
            alias && alias !== name
              ? ts.factory.createExportSpecifier(
                  false,
                  tsc.identifier({ text: name }),
                  tsc.identifier({ text: alias }),
                )
              : ts.factory.createExportSpecifier(
                  false,
                  undefined,
                  tsc.identifier({ text: name }),
                );
          namedSpecifiers.push(specifier);
        }
      }

      const node = ts.factory.createExportDeclaration(
        undefined,
        isTypeOnly,
        ts.factory.createNamedExports(namedSpecifiers),
        tsc.stringLiteral({ isSingleQuote: true, text: from }),
      );
      statements.push(tsNodeToString({ node }));
    }

    if (statements.length) {
      statements.push('');
    }

    let exports = statements.join('\n');
    exports = replaceWrappedIds(exports, (symbolId) =>
      this.replacerFn({ file, headless: false, scope: 'file', symbolId }),
    );
    return exports;
  }

  renderHeader(file: ICodegenFile, meta?: ICodegenMeta): string {
    if (!file.hasContent()) {
      return '';
    }
    const result = [this.renderHeaders(), this.renderImports(file, meta)]
      .filter(Boolean)
      .join('\n');
    // extra line between headers and symbols
    return result.endsWith('\n') ? `${result}\n` : `${result}\n\n`;
  }

  private renderHeaders(): string {
    return ['// This file is auto-generated by @hey-api/openapi-ts', ''].join(
      '\n',
    );
  }

  private renderImports(file: ICodegenFile, meta?: ICodegenMeta): string {
    const grouped = this.groupByKey(file, 'imports', meta);
    const statements: Array<string> = [];

    for (const [from, group] of grouped.entries()) {
      const specifiers: Array<ts.ImportSpecifier> = [];
      let defaultImport: ts.Identifier | undefined;
      let namespaceImport: string | undefined;
      let isTypeOnly = false;

      for (const value of group) {
        if (value.defaultImport) {
          defaultImport = tsc.identifier({ text: value.defaultImport });
          if (value.typeDefaultImport) {
            isTypeOnly = true;
          }
        }

        if (typeof value.namespaceImport === 'string') {
          namespaceImport = replaceWrappedIds(
            value.namespaceImport,
            (symbolId) => this.replacerFn({ file, symbolId }),
          );
          if (value.typeNamespaceImport) {
            isTypeOnly = true;
          }
        }

        if (value.names && value.names.length > 0) {
          if (
            !isTypeOnly &&
            value.names.every((name) => value.typeNames?.includes(name))
          ) {
            isTypeOnly = true;
          }

          for (const name of value.names) {
            const alias = value.aliases?.[name];
            let finalName = name;
            let finalAlias: string | undefined;
            if (alias && alias !== finalName) {
              finalAlias = finalName;
              finalName = alias;
            }
            finalName = replaceWrappedIds(finalName, (symbolId) => {
              const name = this.replacerFn({ file, symbolId });
              const sourceFile = file.project.getFileBySymbolId(symbolId);
              const sourceName = sourceFile
                ? sourceFile.resolvedNames.get(symbolId)
                : undefined;
              if (sourceName && sourceName !== name) {
                // handle only simple imports for now
                if (!finalAlias) {
                  finalAlias = sourceName;
                }
              }
              return name;
            });
            if (finalAlias) {
              finalAlias = replaceWrappedIds(finalAlias, (symbolId) =>
                this.replacerFn({ file, symbolId }),
              );
              // remove redundant alias
              if (finalAlias === finalName) {
                finalAlias = undefined;
              }
            }
            const specifier = ts.factory.createImportSpecifier(
              isTypeOnly ? false : (value.typeNames?.includes(name) ?? false),
              finalAlias ? tsc.identifier({ text: finalAlias }) : undefined,
              tsc.identifier({ text: finalName }),
            );
            specifiers.push(specifier);
          }
        }
      }

      const importClause = ts.factory.createImportClause(
        isTypeOnly,
        defaultImport,
        namespaceImport
          ? ts.factory.createNamespaceImport(
              tsc.identifier({ text: namespaceImport }),
            )
          : specifiers.length
            ? ts.factory.createNamedImports(specifiers)
            : undefined,
      );

      const node = ts.factory.createImportDeclaration(
        undefined,
        importClause,
        tsc.stringLiteral({ isSingleQuote: true, text: from }),
      );
      statements.push(tsNodeToString({ node }));
    }

    if (statements.length) {
      statements.push('');
    }

    return statements.join('\n');
  }

  renderSymbols(file: ICodegenFile, meta?: ICodegenMeta): string {
    if (!file.hasContent()) {
      return '';
    }
    const result = [this.renderBody(file), this.renderExports(file, meta)]
      .filter(Boolean)
      .join('\n');
    return result.endsWith('\n') ? result : `${result}\n`;
  }

  replacerFn({
    file,
    headless = true,
    scope = 'project',
    symbolId,
  }: {
    file: ICodegenFile;
    headless?: boolean;
    scope?: 'file' | 'project';
    symbolId: number;
  }): string | undefined {
    const cached = file.resolvedNames.get(symbolId);
    if (cached) return cached;
    const symbol =
      scope === 'file'
        ? file.getSymbolById(symbolId)
        : file.project.getSymbolById(symbolId);
    if (!symbol || (!headless && symbol.value === undefined)) return;
    let name = this.ensureValidName(symbol.name);
    if (file.resolvedNames.hasValue(name)) {
      name = this.getUniqueName(name, file.resolvedNames);
    }
    file.resolvedNames.set(symbolId, name);
    return name;
  }
}
