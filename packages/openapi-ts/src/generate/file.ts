import fs from 'node:fs';
import path from 'node:path';

import ts from 'typescript';

import { tsc } from '~/tsc';
import { type ImportExportItemObject, tsNodeToString } from '~/tsc/utils';

import { ensureDirSync } from './utils';

type FileImportResult<
  Name extends string | undefined = string | undefined,
  Alias extends string | undefined = undefined,
> = {
  asType?: boolean;
  name: Alias extends string ? Alias : Name;
};

/**
 * TODO: remove, it's used by legacy plugins
 *
 * @deprecated
 */
export class GeneratedFile {
  /**
   * Should the exports from this file be re-exported in the index barrel file?
   */
  private _exportFromIndex: boolean;
  private _headers: Array<string> = [];
  private _id: string;
  private _imports = new Map<string, Map<string, ImportExportItemObject>>();
  private _items: Array<ts.Node | string> = [];
  private _name: string;
  private _path: string;

  public constructor({
    dir,
    exportFromIndex = false,
    header = true,
    id,
    name,
  }: {
    dir: string;
    /**
     * Should the exports from this file be re-exported in the index barrel file?
     */
    exportFromIndex?: boolean;
    header?: boolean;
    /**
     * Unique file ID. Used to generate correct relative paths to the file.
     * This should be refactored later as it's basically the file name unless
     * nested inside another folder.
     */
    id: string;
    name: string;
  }) {
    this._exportFromIndex = exportFromIndex;
    this._id = id;
    this._name = this._setName(name);
    this._path = path.resolve(dir, this._name);

    if (header) {
      this._headers.push(
        '// This file is auto-generated by @hey-api/openapi-ts',
      );
    }
  }

  public add(...nodes: Array<ts.Node | string>) {
    this._items = this._items.concat(nodes);
  }

  public get exportFromIndex(): boolean {
    return this._exportFromIndex;
  }

  public get id(): string {
    return this._id;
  }

  /**
   * Adds an import to the provided module. Handles duplication, returns added
   * import. Returns the imported name. If we import an aliased export, `name`
   * will be equal to the specified `alias`.
   */
  public import<
    Name extends string | undefined = string | undefined,
    Alias extends string | undefined = undefined,
  >({
    module,
    ...importedItem
  }: ImportExportItemObject<Name, Alias> & {
    module: string;
  }): FileImportResult<Name, Alias> {
    if (!importedItem.name) {
      return {
        name: undefined as any,
      };
    }

    let moduleMap = this._imports.get(module);

    if (!moduleMap) {
      moduleMap = new Map<string, ImportExportItemObject>();
      this._imports.set(module, moduleMap);
    }

    const match = moduleMap.get(importedItem.name);
    if (match) {
      return {
        ...match,
        name: (match.alias || match.name) as any,
      };
    }

    moduleMap.set(importedItem.name, importedItem as any);
    return {
      ...importedItem,
      name: (importedItem.alias || importedItem.name) as any,
    };
  }

  public isEmpty() {
    return !this._items.length;
  }

  public nameWithoutExtension() {
    const { name } = splitNameAndExtension(this._name);
    return name;
  }

  public remove(options?: Parameters<typeof fs.rmSync>[1]) {
    fs.rmSync(this._path, options);
  }

  /**
   * Removes last node form the stack. Works as undo.
   *
   * @deprecated
   */
  public removeNode_LEGACY() {
    this._items = this._items.slice(0, this._items.length - 1);
  }

  private _setName(fileName: string) {
    if (fileName.includes('index')) {
      return fileName;
    }

    const { extension, name } = splitNameAndExtension(fileName);
    return [name, 'gen', extension].filter(Boolean).join('.');
  }

  private _toString(separator: string, tsConfig: ts.ParsedCommandLine | null) {
    let output: Array<string> = [];
    if (this._headers.length) {
      output.push(this._headers.join('\n'));
    }

    const shouldAppendJs =
      tsConfig?.options.moduleResolution === ts.ModuleResolutionKind.NodeNext;

    const importsStringArray: Array<string> = [];

    for (const [_module, moduleMap] of this._imports.entries()) {
      const imports = Array.from(moduleMap.values());

      let resolvedModule = _module;
      if (
        shouldAppendJs &&
        (resolvedModule.startsWith('./') || resolvedModule.startsWith('../'))
      ) {
        if (resolvedModule === './client') {
          resolvedModule = './client/index.js';
        } else {
          resolvedModule = `${resolvedModule}.js`;
        }
      }

      const node = tsc.namedImportDeclarations({
        imports,
        module: resolvedModule,
      });
      importsStringArray.push(tsNodeToString({ node }));
    }
    if (importsStringArray.length) {
      output.push(importsStringArray.join('\n'));
    }
    output = output.concat(
      this._items.map((node) =>
        typeof node === 'string'
          ? node
          : tsNodeToString({ node, unescape: true }),
      ),
    );
    return output.join(separator);
  }

  public write(separator = '\n', tsConfig: ts.ParsedCommandLine | null = null) {
    if (this.isEmpty()) {
      this.remove({ force: true });
      return;
    }

    let dir = this._path;
    if (typeof this._path === 'string') {
      const parts = this._path.split(path.sep);
      dir = parts.slice(0, parts.length - 1).join(path.sep);
    }
    ensureDirSync(dir);
    fs.writeFileSync(this._path, this._toString(separator, tsConfig));
  }
}

export const splitNameAndExtension = (fileName: string) => {
  const match = fileName.match(/\.[0-9a-z]+$/i);
  const extension = match ? match[0].slice(1) : '';
  const name = fileName.slice(
    0,
    fileName.length - (extension ? extension.length + 1 : 0),
  );
  return { extension, name };
};
